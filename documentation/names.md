# Spec Names vs. Metadata Names

Every object in PreQL must have a `.metadata.name` field. Some objects also
require a `.spec.name` field as well, whereas others do not. The use case for
the two differ from each other: in objects where `.spec.name` is required or
permitted, it is the actual identifier that will be given to an object in the
transpiled language (the target); this means that all referential integrity
checks shall be performed against the `.spec.name`s of the objects in question,
and not the `.metadata.name`. The `.metadata.name` shall be used everywhere
else.

In summary, `.spec.name`:

- Is used for:
  - The actual identifier used in the resulting transpiled language.
  - Performing referential integrity checks, or something similar.
- Does not always have to be globally unique, depending on the type of object.
- Is not always required.

Whereas `.metadata.name`:

- Is used for:
  - Error messages generated by PreQL.
- Must form a globally-unique pair when combined with the `.kind` value.
  - In other words, you cannot have two `Attributes` with a `.metadata.name`
    of `floofy`, but you _may_ have an `Attribute` and a `Struct` both named
    `floofy`.
- Is always required.

Generally, `.spec.name` will be required when it is not an issue for two types
to conflict in name. For example, two `Attribute`s may have the same name as
long as they belong to separate `Struct`s, so `Attribute` uses a `.spec.name`
field.